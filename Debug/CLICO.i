# 1 ".././CLICO.c"
# 1 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\AVRStudio\\CLICO\\CLICO\\Debug//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 ".././CLICO.c"
# 17 ".././CLICO.c"
# 1 ".././CLICO.h" 1
# 24 ".././CLICO.h"
# 1 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/avr/io.h" 1
# 99 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/avr/io.h"
# 1 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/avr/sfr_defs.h" 1
# 126 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/avr/sfr_defs.h"
# 1 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/inttypes.h" 1
# 37 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/inttypes.h"
# 1 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/stdint.h" 1
# 121 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/stdint.h"
typedef int int8_t __attribute__((__mode__(__QI__)));
typedef unsigned int uint8_t __attribute__((__mode__(__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int uint16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int uint32_t __attribute__ ((__mode__ (__SI__)));

typedef int int64_t __attribute__((__mode__(__DI__)));
typedef unsigned int uint64_t __attribute__((__mode__(__DI__)));
# 142 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/stdint.h"
typedef int16_t intptr_t;




typedef uint16_t uintptr_t;
# 159 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/stdint.h"
typedef int8_t int_least8_t;




typedef uint8_t uint_least8_t;




typedef int16_t int_least16_t;




typedef uint16_t uint_least16_t;




typedef int32_t int_least32_t;




typedef uint32_t uint_least32_t;







typedef int64_t int_least64_t;






typedef uint64_t uint_least64_t;
# 213 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/stdint.h"
typedef int8_t int_fast8_t;




typedef uint8_t uint_fast8_t;




typedef int16_t int_fast16_t;




typedef uint16_t uint_fast16_t;




typedef int32_t int_fast32_t;




typedef uint32_t uint_fast32_t;







typedef int64_t int_fast64_t;






typedef uint64_t uint_fast64_t;
# 273 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/stdint.h"
typedef int64_t intmax_t;




typedef uint64_t uintmax_t;
# 38 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/inttypes.h" 2
# 77 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/inttypes.h"
typedef int32_t int_farptr_t;



typedef uint32_t uint_farptr_t;
# 127 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/avr/sfr_defs.h" 2
# 100 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/avr/io.h" 2
# 152 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/avr/io.h"
# 1 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/avr/iom128.h" 1
# 153 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/avr/io.h" 2
# 446 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/avr/io.h"
# 1 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/avr/portpins.h" 1
# 447 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/avr/io.h" 2

# 1 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/avr/common.h" 1
# 449 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/avr/io.h" 2

# 1 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/avr/version.h" 1
# 451 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/avr/io.h" 2


# 1 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/avr/fuse.h" 1
# 239 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/avr/fuse.h"
typedef struct
{
    unsigned char low;
    unsigned char high;
    unsigned char extended;
} __fuse_t;
# 454 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/avr/io.h" 2


# 1 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/avr/lock.h" 1
# 457 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/avr/io.h" 2
# 25 ".././CLICO.h" 2
# 1 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/avr/interrupt.h" 1
# 26 ".././CLICO.h" 2

# 1 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/string.h" 1
# 45 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/string.h"
# 1 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/include/stddef.h" 1 3 4
# 211 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/include/stddef.h" 3 4
typedef unsigned int size_t;
# 46 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/string.h" 2
# 111 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/string.h"
extern int ffs (int __val) __attribute__((__const__));
extern int ffsl (long __val) __attribute__((__const__));
extern int ffsll (long long __val) __attribute__((__const__));
extern void *memccpy(void *, const void *, int, size_t);
extern void *memchr(const void *, int, size_t) __attribute__((__pure__));
extern int memcmp(const void *, const void *, size_t) __attribute__((__pure__));
extern void *memcpy(void *, const void *, size_t);
extern void *memmem(const void *, size_t, const void *, size_t) __attribute__((__pure__));
extern void *memmove(void *, const void *, size_t);
extern void *memrchr(const void *, int, size_t) __attribute__((__pure__));
extern void *memset(void *, int, size_t);
extern char *strcat(char *, const char *);
extern char *strchr(const char *, int) __attribute__((__pure__));
extern char *strchrnul(const char *, int) __attribute__((__pure__));
extern int strcmp(const char *, const char *) __attribute__((__pure__));
extern char *strcpy(char *, const char *);
extern int strcasecmp(const char *, const char *) __attribute__((__pure__));
extern char *strcasestr(const char *, const char *) __attribute__((__pure__));
extern size_t strcspn(const char *__s, const char *__reject) __attribute__((__pure__));
extern char *strdup(const char *s1);
extern size_t strlcat(char *, const char *, size_t);
extern size_t strlcpy(char *, const char *, size_t);
extern size_t strlen(const char *) __attribute__((__pure__));
extern char *strlwr(char *);
extern char *strncat(char *, const char *, size_t);
extern int strncmp(const char *, const char *, size_t) __attribute__((__pure__));
extern char *strncpy(char *, const char *, size_t);
extern int strncasecmp(const char *, const char *, size_t) __attribute__((__pure__));
extern size_t strnlen(const char *, size_t) __attribute__((__pure__));
extern char *strpbrk(const char *__s, const char *__accept) __attribute__((__pure__));
extern char *strrchr(const char *, int) __attribute__((__pure__));
extern char *strrev(char *);
extern char *strsep(char **, const char *);
extern size_t strspn(const char *__s, const char *__accept) __attribute__((__pure__));
extern char *strstr(const char *, const char *) __attribute__((__pure__));
extern char *strtok(char *, const char *);
extern char *strtok_r(char *, const char *, char **);
extern char *strupr(char *);
# 28 ".././CLICO.h" 2

# 1 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/util/delay.h" 1
# 43 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/util/delay.h"
# 1 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/util/delay_basic.h" 1
# 40 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/util/delay_basic.h"
static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
# 80 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/util/delay_basic.h"
void
_delay_loop_1(uint8_t __count)
{
 __asm__ volatile (
  "1: dec %0" "\n\t"
  "brne 1b"
  : "=r" (__count)
  : "0" (__count)
 );
}
# 102 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/util/delay_basic.h"
void
_delay_loop_2(uint16_t __count)
{
 __asm__ volatile (
  "1: sbiw %0,1" "\n\t"
  "brne 1b"
  : "=w" (__count)
  : "0" (__count)
 );
}
# 44 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/util/delay.h" 2
# 83 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/util/delay.h"
static inline void _delay_us(double __us) __attribute__((always_inline));
static inline void _delay_ms(double __ms) __attribute__((always_inline));
# 131 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/util/delay.h"
void
_delay_ms(double __ms)
{
 uint16_t __ticks;
 double __tmp ;

 uint32_t __ticks_dc;
 extern void __builtin_avr_delay_cycles(unsigned long);
 __tmp = ((16000000UL) / 1e3) * __ms;
# 149 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/util/delay.h"
  __ticks_dc = (uint32_t)(ceil(fabs(__tmp)));


 __builtin_avr_delay_cycles(__ticks_dc);
# 174 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/util/delay.h"
}
# 208 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/util/delay.h"
void
_delay_us(double __us)
{
 uint8_t __ticks;
 double __tmp ;

 uint32_t __ticks_dc;
 extern void __builtin_avr_delay_cycles(unsigned long);
 __tmp = ((16000000UL) / 1e6) * __us;
# 226 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/util/delay.h"
  __ticks_dc = (uint32_t)(ceil(fabs(__tmp)));


 __builtin_avr_delay_cycles(__ticks_dc);
# 244 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/util/delay.h"
}
# 30 ".././CLICO.h" 2
# 1 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/util/24c_.c" 1







# 1 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/util/24c_.h" 1



void EEOpen(void);
uint8_t EEWriteByte(uint16_t address, uint8_t data);
uint8_t EEReadByte(uint16_t address);
# 9 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/util/24c_.c" 2

void EEOpen(void)
{

 (*(volatile uint8_t *)(0x70)) = 12;
 (*(volatile uint8_t *)(0x71)) &= (~((1<<1)|(1<<0)));
 return;
}

uint8_t EEWriteByte(uint16_t address,uint8_t data)
{
 do
 {
  (*(volatile uint8_t *)(0x74))=(1<<7)|(1<<5)|(1<<2);

  while(!((*(volatile uint8_t *)(0x74)) & (1<<7)));

  if(((*(volatile uint8_t *)(0x71)) & 0xF8) != 0x08)
   return 0;



  (*(volatile uint8_t *)(0x73))=0b10100000;


  (*(volatile uint8_t *)(0x74))=(1<<7)|(1<<2);


  while(!((*(volatile uint8_t *)(0x74)) & (1<<7)));

 }while(((*(volatile uint8_t *)(0x71)) & 0xF8) != 0x18);

 (*(volatile uint8_t *)(0x73))=(address>>8);

 (*(volatile uint8_t *)(0x74))=(1<<7)|(1<<2);

 while(!((*(volatile uint8_t *)(0x74)) & (1<<7)));

 if(((*(volatile uint8_t *)(0x71)) & 0xF8) != 0x28)
  return 0;

 (*(volatile uint8_t *)(0x73))=(address);

 (*(volatile uint8_t *)(0x74))=(1<<7)|(1<<2);

 while(!((*(volatile uint8_t *)(0x74)) & (1<<7)));

 if(((*(volatile uint8_t *)(0x71)) & 0xF8) != 0x28)
  return 0;

 (*(volatile uint8_t *)(0x73))=(data);

 (*(volatile uint8_t *)(0x74))=(1<<7)|(1<<2);

 while(!((*(volatile uint8_t *)(0x74)) & (1<<7)));

 if(((*(volatile uint8_t *)(0x71)) & 0xF8) != 0x28)
  return 0;

 (*(volatile uint8_t *)(0x74))=(1<<7)|(1<<2)|(1<<4);

 while((*(volatile uint8_t *)(0x74)) & (1<<4));



 return 1;

}

uint8_t EEReadByte(uint16_t address)
{
 uint8_t data;


 do
 {

  (*(volatile uint8_t *)(0x74))=(1<<7)|(1<<5)|(1<<2);


  while(!((*(volatile uint8_t *)(0x74)) & (1<<7)));


  if(((*(volatile uint8_t *)(0x71)) & 0xF8) != 0x08)
   return 0;



  (*(volatile uint8_t *)(0x73))=0b10100000;


  (*(volatile uint8_t *)(0x74))=(1<<7)|(1<<2);


  while(!((*(volatile uint8_t *)(0x74)) & (1<<7)));

 }while(((*(volatile uint8_t *)(0x71)) & 0xF8) != 0x18);



 (*(volatile uint8_t *)(0x73))=(address>>8);


 (*(volatile uint8_t *)(0x74))=(1<<7)|(1<<2);


 while(!((*(volatile uint8_t *)(0x74)) & (1<<7)));


 if(((*(volatile uint8_t *)(0x71)) & 0xF8) != 0x28)
  return 0;


 (*(volatile uint8_t *)(0x73))=(address);


 (*(volatile uint8_t *)(0x74))=(1<<7)|(1<<2);


 while(!((*(volatile uint8_t *)(0x74)) & (1<<7)));


 if(((*(volatile uint8_t *)(0x71)) & 0xF8) != 0x28)
  return 0;






 (*(volatile uint8_t *)(0x74))=(1<<7)|(1<<5)|(1<<2);


 while(!((*(volatile uint8_t *)(0x74)) & (1<<7)));


 if(((*(volatile uint8_t *)(0x71)) & 0xF8) != 0x10)
  return 0;



 (*(volatile uint8_t *)(0x73))=0b10100001;


 (*(volatile uint8_t *)(0x74))=(1<<7)|(1<<2);


 while(!((*(volatile uint8_t *)(0x74)) & (1<<7)));


 if(((*(volatile uint8_t *)(0x71)) & 0xF8) != 0x40)
  return 0;


 (*(volatile uint8_t *)(0x74))=(1<<7)|(1<<2);


 while(!((*(volatile uint8_t *)(0x74)) & (1<<7)));


 if(((*(volatile uint8_t *)(0x71)) & 0xF8) != 0x58)
  return 0;


 data=(*(volatile uint8_t *)(0x73));


 (*(volatile uint8_t *)(0x74))=(1<<7)|(1<<2)|(1<<4);


 while((*(volatile uint8_t *)(0x74)) & (1<<4));


 return data;
}
# 31 ".././CLICO.h" 2
# 1 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/util/atomic.h" 1
# 42 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/util/atomic.h"
static __inline__ uint8_t __iSeiRetVal(void)
{
    __asm__ __volatile__ ("sei" ::: "memory");
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    __asm__ __volatile__ ("cli" ::: "memory");
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    __asm__ __volatile__ ("sei" ::: "memory");
    __asm__ volatile ("" ::: "memory");
    (void)__s;
}

static __inline__ void __iCliParam(const uint8_t *__s)
{
    __asm__ __volatile__ ("cli" ::: "memory");
    __asm__ volatile ("" ::: "memory");
    (void)__s;
}

static __inline__ void __iRestore(const uint8_t *__s)
{
    (*(volatile uint8_t *)((0x3F) + 0x20)) = *__s;
    __asm__ volatile ("" ::: "memory");
}
# 32 ".././CLICO.h" 2

# 1 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/CLICO_util/lcd.c" 1
# 25 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/CLICO_util/lcd.c"
# 1 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/CLICO_util/lcd.h" 1
# 9 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/CLICO_util/lcd.h"
# 1 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/CLICO_util/myutils.h" 1
# 10 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/CLICO_util/lcd.h" 2
# 49 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/CLICO_util/lcd.h"
void InitLCD(uint8_t style);
void LCDWriteString(const char *msg);
void LCDWriteInt(int val,unsigned int field_length);
void LCDGotoXY(uint8_t x,uint8_t y);
void LCDWriteStringXY(uint8_t x, uint8_t y, const char *msg);


void LCDByte(uint8_t,uint8_t);




void LCDBusyLoop();
# 26 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/CLICO_util/lcd.c" 2
# 51 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/CLICO_util/lcd.c"
void LCDByte(uint8_t c,uint8_t isdata)
{







 uint8_t hn,ln;
 uint8_t temp;

 hn=c>>4;
 ln=(c & 0x0F);

 if(isdata==0)
  ((*(volatile uint8_t *)((0x15) + 0x20))&=(~(1<<1)));
 else
  ((*(volatile uint8_t *)((0x15) + 0x20))|=(1<<1));

 _delay_us(0.5f);

 ((*(volatile uint8_t *)((0x15) + 0x20))|=(1<<2));



 temp=((*(volatile uint8_t *)((0x1B) + 0x20)) & 0XF0)|(hn);
 (*(volatile uint8_t *)((0x1B) + 0x20))=temp;

 _delay_us(1);



 ((*(volatile uint8_t *)((0x15) + 0x20))&=(~(1<<2)));

 _delay_us(1);


 ((*(volatile uint8_t *)((0x15) + 0x20))|=(1<<2));

 temp=((*(volatile uint8_t *)((0x1B) + 0x20)) & 0XF0)|(ln);

 (*(volatile uint8_t *)((0x1B) + 0x20))=temp;

 _delay_us(1);



 ((*(volatile uint8_t *)((0x15) + 0x20))&=(~(1<<2)));

 _delay_us(1);

 LCDBusyLoop();
}

void LCDBusyLoop()
{


 uint8_t busy,status=0x00,temp;


 (*(volatile uint8_t *)((0x1A) + 0x20))&=0xF0;


 ((*(volatile uint8_t *)((0x15) + 0x20))|=(1<<0));
 ((*(volatile uint8_t *)((0x15) + 0x20))&=(~(1<<1)));



 _delay_us(0.5f);

 do
 {

  ((*(volatile uint8_t *)((0x15) + 0x20))|=(1<<2));


  _delay_us(0.5f);

  status=(*(volatile uint8_t *)((0x19) + 0x20));
  status=status<<4;

  _delay_us(0.5f);


  ((*(volatile uint8_t *)((0x15) + 0x20))&=(~(1<<2)));
  _delay_us(1);

  ((*(volatile uint8_t *)((0x15) + 0x20))|=(1<<2));
  _delay_us(0.5f);

  temp=(*(volatile uint8_t *)((0x19) + 0x20));
  temp&=0x0F;

  status=status|temp;

  busy=status & 0b10000000;

  _delay_us(0.5f);
  ((*(volatile uint8_t *)((0x15) + 0x20))&=(~(1<<2)));
  _delay_us(1);
 }while(busy);

 ((*(volatile uint8_t *)((0x15) + 0x20))&=(~(1<<0)));

 (*(volatile uint8_t *)((0x1A) + 0x20))|=0x0F;

}

void InitLCD(uint8_t style)
{
# 176 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/CLICO_util/lcd.c"
 _delay_ms(30);


 (*(volatile uint8_t *)((0x1A) + 0x20))|=(0x0F);
 (*(volatile uint8_t *)((0x14) + 0x20))|=(1<<2);
 (*(volatile uint8_t *)((0x14) + 0x20))|=(1<<1);
 (*(volatile uint8_t *)((0x14) + 0x20))|=(1<<0);

 (*(volatile uint8_t *)((0x1B) + 0x20))&=0XF0;
 ((*(volatile uint8_t *)((0x15) + 0x20))&=(~(1<<2)));
 ((*(volatile uint8_t *)((0x15) + 0x20))&=(~(1<<0)));
 ((*(volatile uint8_t *)((0x15) + 0x20))&=(~(1<<1)));


 _delay_us(0.3f);

 ((*(volatile uint8_t *)((0x15) + 0x20))|=(1<<2));
 (*(volatile uint8_t *)((0x1B) + 0x20))|=(0b00000010);
 _delay_us(1);
 ((*(volatile uint8_t *)((0x15) + 0x20))&=(~(1<<2)));
 _delay_us(1);


 LCDBusyLoop();



 (LCDByte(0b00001100|style,0));
 (LCDByte(0b00101000,0));
}
void LCDWriteString(const char *msg)
{
# 218 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/CLICO_util/lcd.c"
 while(*msg!='\0')
 {
 (LCDByte(*msg,1));
 msg++;
 }
}

void LCDWriteInt(int val,unsigned int field_length)
{
# 238 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/CLICO_util/lcd.c"
 char str[5]={0,0,0,0,0};
 int i=4,j=0;
 while(val)
 {
 str[i]=val%10;
 val=val/10;
 i--;
 }
 if(field_length==-1)
  while(str[j]==0) j++;
 else
  j=5-field_length;

 if(val<0) (LCDByte('-',1));
 for(i=j;i<5;i++)
 {
 (LCDByte(48+str[i],1));
 }
}
void LCDGotoXY(uint8_t x,uint8_t y)
{
 if(x<40)
 {
  if(y) x|=0b01000000;
  x|=0b10000000;
  (LCDByte(x,0));
  }
}

void LCDWriteStringXY(uint8_t x, uint8_t y, const char *msg){
 LCDGotoXY(x, y);
 LCDWriteString(msg);
}
# 34 ".././CLICO.h" 2
# 1 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/CLICO_util/EEPROM.c" 1






# 1 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/CLICO_util/EEPROM.h" 1
# 40 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/CLICO_util/EEPROM.h"
unsigned char EEPROM_open (void);
# 57 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/CLICO_util/EEPROM.h"
unsigned char EEPROM_readByte( uint16_t address, unsigned char ACK);


unsigned char EEPROM_writeByte( uint16_t address, uint8_t data, unsigned char ACK);
unsigned char * EEPROM_readPage( unsigned int pageNumber );
unsigned char EEPROM_writePage( unsigned int pageNumber, unsigned char * data );
unsigned char EEPROM_sequentialRead(uint16_t address, uint16_t numOfBytes, unsigned char * dest, unsigned char ACK);
unsigned char EEPROM_sequentialWrite(uint16_t address, uint16_t numOfBytes, unsigned char * data);
unsigned char EEPROM_erase( void );
# 8 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/CLICO_util/EEPROM.c" 2
# 1 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/CLICO_util/i2c.h" 1
# 28 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/CLICO_util/i2c.h"
unsigned char i2c_start(void);
unsigned char i2c_start_address(unsigned char);
unsigned char i2c_repeatStart(void);
unsigned char i2c_sendAddress_ACK(unsigned char);
unsigned char i2c_sendAddress_NACK(unsigned char);
unsigned char i2c_sendData_ACK(unsigned char);
unsigned char i2c_sendData_NACK(unsigned char);
unsigned char i2c_receiveData_ACK(void);
unsigned char i2c_receiveData_NACK(void);

void i2c_stop(void);
# 9 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/CLICO_util/EEPROM.c" 2


uint8_t EEPROM_Open()
{

 (*(volatile uint8_t *)(0x71)) = 0;
 (*(volatile uint8_t *)(0x70)) = ((16000000UL / 400000UL) - 16) / 2;
 if ((*(volatile uint8_t *)(0x70)) < 11)
  return 0;
 return 1;
}



unsigned char EEPROM_readByte(uint16_t address, unsigned char ACK){

 unsigned char errorStatus, i, data;
 uint8_t highAddress, lowAddress;
 highAddress=(address>>8);
 lowAddress=(address);

 if((i2c_start_address(0xa0))!=0){
  i2c_stop();
  return 0x7e -1;
 }
 errorStatus |= i2c_sendData_ACK(highAddress);
 errorStatus |= i2c_sendData_ACK(lowAddress);

 errorStatus |= i2c_repeatStart();

 errorStatus |= i2c_sendAddress_ACK(0xa1);

 if(errorStatus==1){
  i2c_stop();
  return 0x7e -1;
 }

 if(ACK)
  data = i2c_receiveData_ACK();
 else
  data = i2c_receiveData_NACK();

 if(data == 0x7e){
  i2c_stop();
     return 0x7e -1;
 }
 i2c_stop();
 return data;
}


unsigned char EEPROM_writeByte(uint16_t address, uint8_t data, unsigned char ACK){

 unsigned char errorStatus, highAddress, lowAddress;
 highAddress=address>>8;
 lowAddress=address;

 errorStatus = i2c_start_address(0xa0);
 errorStatus |= i2c_sendData_ACK(highAddress);
 errorStatus |= i2c_sendData_ACK(lowAddress);

 if(errorStatus == 1){
  i2c_stop();
  return(1);
 }
 if(ACK)
  errorStatus = i2c_sendData_ACK(data);
 else
  errorStatus = i2c_sendData_NACK(data);

 if(errorStatus == 1){
  i2c_stop();
     return(1);
 }

 i2c_stop();
 _delay_ms(5);
 return(0);



}




unsigned char * EEPROM_readPage( unsigned int pageNumber ){

 unsigned char *values;
 unsigned int pageAddress, numOfRead;

 pageAddress = pageNumber * 128;

 numOfRead = EEPROM_sequentialRead(pageAddress, 128, values, 0);
 if(values==((void *)0)){ return ((void *)0); }
 else return values;
 }


unsigned char EEPROM_writePage( unsigned int pageNumber, unsigned char * data ){

 unsigned char highAddress, lowAddress, errorStatus, i;
 unsigned int pageAddress;


 pageAddress = pageNumber * 128;
 for(i=0;i<128;i++){
  errorStatus = EEPROM_writeByte(pageAddress, data[i], 1);
  if(errorStatus){
   i2c_stop();
   return 1;
  }
 }


 return(0);
}


unsigned char EEPROM_sequentialRead(uint16_t address, uint16_t numOfBytes, unsigned char * dest, unsigned char ACK){

 unsigned char errorStatus, i;
 uint8_t highAddress=(address>>8), lowAddress=(address);

 errorStatus = i2c_start();
 _delay_ms(3);
 errorStatus |= i2c_sendAddress_ACK(0xa0);
 errorStatus |= i2c_sendData_ACK(highAddress);
 errorStatus |= i2c_sendData_ACK(lowAddress);
 errorStatus |= i2c_repeatStart();
 errorStatus |= i2c_sendAddress_ACK(0xa1);

 if(errorStatus){
  i2c_stop();
  return errorStatus;
 }

 for(i=0;i<numOfBytes;i++){
  if(ACK)
   *dest = i2c_receiveData_ACK();
  else
   *dest = i2c_receiveData_NACK();

  if(*(++dest) == 0x7e){
   i2c_stop();
      return(0x7e);
  }
 }
 i2c_stop();

 return numOfBytes;
}


unsigned char EEPROM_sequentialWrite(uint16_t address, uint16_t numOfBytes, unsigned char * data){
 unsigned char errorStatus, i;

 for(i=0;i<numOfBytes;i++){
  errorStatus=EEPROM_writeByte(address,data[i], 1);
  if(errorStatus){
   i2c_stop();
   return 1;
  }
 }
 return 0;
}


unsigned char EEPROM_erase(void){

 unsigned char errorStatus;
 unsigned int i;

 errorStatus = i2c_start_address(0xa0);
 errorStatus |= i2c_sendData_ACK(0x00);
 errorStatus |= i2c_sendData_ACK(0x00);
 if(errorStatus == 1){
  i2c_stop();
  return(1);
 }

 for(i=0;i<0x8000;i++){
  errorStatus = i2c_sendData_ACK(0xff);
  if(errorStatus == 1){
   i2c_stop();
   return(1);
  }
 }

 i2c_stop();

 return(0);
}
# 35 ".././CLICO.h" 2
# 1 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/CLICO_util/i2c.c" 1





# 1 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/CLICO_util/i2c.h" 1
# 28 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/CLICO_util/i2c.h"
unsigned char i2c_start(void);
unsigned char i2c_start_address(unsigned char);
unsigned char i2c_repeatStart(void);
unsigned char i2c_sendAddress_ACK(unsigned char);
unsigned char i2c_sendAddress_NACK(unsigned char);
unsigned char i2c_sendData_ACK(unsigned char);
unsigned char i2c_sendData_NACK(unsigned char);
unsigned char i2c_receiveData_ACK(void);
unsigned char i2c_receiveData_NACK(void);

void i2c_stop(void);
# 7 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/CLICO_util/i2c.c" 2


unsigned char i2c_start(void)
{
 (*(volatile uint8_t *)(0x74)) = (1<<7)|(1<<5)|(1<<2);

 while (!((*(volatile uint8_t *)(0x74)) & (1<<7)));


 if ((((*(volatile uint8_t *)(0x71)) & 0xF8) == 0x08) || (((*(volatile uint8_t *)(0x71)) & 0xF8) == 0x10))
  return 0;
 else
  return 1;
}

unsigned char i2c_start_address(unsigned char address)
{
 uint8_t twst;

 (*(volatile uint8_t *)(0x74)) = (1<<7)|(1<<5)|(1<<2);

 while (!((*(volatile uint8_t *)(0x74)) & (1<<7)));

 twst = (*(volatile uint8_t *)(0x71)) & 0xF8;

 if ((twst != 0x08) && (twst != 0x10))
  return 2;

 (*(volatile uint8_t *)(0x73)) = address;
 (*(volatile uint8_t *)(0x74)) = (1<<7)|(1<<2);

 while(!((*(volatile uint8_t *)(0x74)) & (1<<7)));


 twst = (*(volatile uint8_t *)(0x71));

 if ( (twst != 0x18) && (twst != 0x40) )
  return 1;

 return 0;
}

unsigned char i2c_repeatStart(void)
{

 (*(volatile uint8_t *)(0x74)) = (1<<7)|(1<<5)|(1<<2);

 while (!((*(volatile uint8_t *)(0x74)) & (1<<7)));

 if (((*(volatile uint8_t *)(0x71)) & 0xF8) == 0x10)
  return(0);
 else
  return(1);
}


unsigned char i2c_sendAddress_ACK(unsigned char address)
{
 unsigned char STATUS;

 if((address & 0x01) == 0)
  STATUS = 0x18;
 else
  STATUS = 0x40;

 (*(volatile uint8_t *)(0x73)) = address;
 (*(volatile uint8_t *)(0x74)) = (1<<7)|(1<<2);
 (*(volatile uint8_t *)(0x74)) |= (1<<6);

 while (!((*(volatile uint8_t *)(0x74)) & (1<<7)));


 if (((*(volatile uint8_t *)(0x71)) & 0xF8) == STATUS)
  return(0);
 else
  return(1);
}

unsigned char i2c_sendAddress_NACK(unsigned char address)
{
 unsigned char STATUS;

 if((address & 0x01) == 0)
  STATUS = 0x20;
 else
  STATUS = 0x48;

 (*(volatile uint8_t *)(0x73)) = address;
 (*(volatile uint8_t *)(0x74)) = (1<<7)|(1<<2);

 while (!((*(volatile uint8_t *)(0x74)) & (1<<7)));


 if (((*(volatile uint8_t *)(0x71)) & 0xF8) == STATUS)
  return(0);
 else
  return(1);
}

unsigned char i2c_sendData_ACK(unsigned char data)
{
 (*(volatile uint8_t *)(0x73)) = data;
 (*(volatile uint8_t *)(0x74)) = (1<<7)|(1<<2)|(1<<6);

 while (!((*(volatile uint8_t *)(0x74)) & (1<<7)));

 if (((*(volatile uint8_t *)(0x71)) & 0xF8) == 0x28)
  return(0);
 else
  return(1);
}
unsigned char i2c_sendData_NACK(unsigned char data)
{
 (*(volatile uint8_t *)(0x73)) = data;
 (*(volatile uint8_t *)(0x74)) = (1<<7)|(1<<2);

 while (!((*(volatile uint8_t *)(0x74)) & (1<<7)));

 if (((*(volatile uint8_t *)(0x71)) & 0xF8) == 0x30)
  return(0);
 else
  return(1);
}



unsigned char i2c_receiveData_ACK(void)
{
 unsigned char data;

 (*(volatile uint8_t *)(0x74)) = (1<<6)|(1<<7)|(1<<2);

 while (!((*(volatile uint8_t *)(0x74)) & (1<<7)));

 if (((*(volatile uint8_t *)(0x71)) & 0xF8) != 0x50)
  return(0x7e);

 data = (*(volatile uint8_t *)(0x73));
 return(data);
}


unsigned char i2c_receiveData_NACK(void)
{
 unsigned char data;

 (*(volatile uint8_t *)(0x74)) = (1<<7)|(1<<2);

 while (!((*(volatile uint8_t *)(0x74)) & (1<<7)));

 if (((*(volatile uint8_t *)(0x71)) & 0xF8) != 0x58)
  return(0x7e);

 data = (*(volatile uint8_t *)(0x73));
 return(data);
}
# 181 "C:\\Users\\cillino\\Dropbox\\internal_sharing\\avrStudio_include/CLICO_util/i2c.c"
void i2c_stop(void)
{
 (*(volatile uint8_t *)(0x74)) = (1<<7)|(1<<2)|(1<<4);
 while((*(volatile uint8_t *)(0x74)) & (1<<4));
}
# 36 ".././CLICO.h" 2




typedef uint8_t byte;
typedef uint16_t word;
typedef uint32_t longword;


typedef struct{
 word wMilli;
 byte bSec;
 byte bMin;
 byte bHour;
 byte bDay;
 byte bMonth;
 byte bYear;
} time_date;

typedef struct{
 byte bMin;
 byte bHour;
} time;

typedef struct{
 word wA;
 word wB;
 word wC;
 word wAB;
} count;

typedef struct{
 byte val_int;
 byte val_dec;
} read;
# 220 ".././CLICO.h"
void _init(void);
double getTemperature(void);
byte getHumidity(void);
void multiplexADChannel(void);
double ADC_average(double * valuesDOUBLE, byte * valuesBYTE);
void refreshQuote(void);
int isLeapYear(byte year);
void changeEditDate(byte bPosition, byte bButton);
void changeEditTimeDate(byte bPosition, byte bButton);
int checkDate(time_date *time, byte* days);
void toggleTimeColon(void);
int _round(double x);

char *itoa(int value, char * str, int base);
int sprintf(char * str, const char * format, ...);
# 18 ".././CLICO.c" 2

volatile time_date tTime;
volatile time_date tTimeEditing;
volatile count cButtonIntegrator;

volatile byte bTimeChanged;
volatile byte bDateChanged=1;
volatile byte bTempChanged;
volatile byte bHumChanged;
volatile byte bFirst=1;

volatile word wADC_garbage;
volatile word wADC_counts;
volatile byte bChannel;

volatile word wBacklightCounter;

volatile double dVp;
volatile double dRpt;
volatile double dTemperature;
volatile double adTemperature[100];
volatile double dTemperatureOld;

volatile double AD;
volatile double dRH;
volatile double dRH_comp;
volatile double dVout;
volatile byte bHumidity;
volatile byte adHumidity[100];
volatile byte bOvFlo;

volatile byte bBtnAPressed;
volatile byte bBtnBPressed;
volatile byte bBtnCPressed;
volatile byte bInhibite;
volatile byte bPort;

volatile byte bSelectionMenu;
volatile byte bSelectionMenuChanged;
volatile byte bSelectionDate;
volatile byte bSelectionDateChanged;
volatile byte bSelectionTime;
volatile byte bSelectionTimeChanged;
volatile byte bTimeCommaState;
volatile byte bTimeColonToToggle;

volatile byte bZone=1;
volatile time tZ1;
volatile time tZ2;

volatile byte sreg;
volatile byte bPriLev;
volatile byte bState=0;
volatile byte bBtn;

char str[10]="";
char options[7 +1][16]={"1.Timezone     ","2.Date         ", "3.Time         ",
     "4.USB transfer ", "5.hello        ", "6.world        ", "7.osti         ", "               "};


byte aDays[12]={31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};


volatile unsigned long i=0;
volatile unsigned char val[11], *val1;






int main(void){
 bPriLev=9;

 tTime.bDay=7;
 tTime.bMonth=8;
 tTime.bYear=11;



 _init();

 while(1) {

  (LCDByte(0b00000001,0));;

  if(!EEPROM_Open()){
   (LCDByte(0b00000001,0));;
   sprintf(str, "Error: bitrate");
   LCDWriteStringXY(0,0,str);
   sprintf(str, "  too high!");
   LCDWriteStringXY(0,1,str);
   _delay_ms(1000);
  }


  unsigned char ch, da;

  for(i=0; i<15; i++){
   ch = EEPROM_writeByte(i, i, 1);
  }

  if(ch==1) {
   (LCDByte(0b00000001,0));;
   sprintf(str, "error while writing");
   LCDWriteStringXY(0,0, str);
   _delay_ms(500);
  }

  for(i=0;i<5;i++){
   da=EEPROM_readByte(i, 0);

   sprintf(str, "%d at %d", da, i);
   (LCDByte(0b00000001,0));;
   LCDWriteStringXY(0,0,str);
   _delay_ms(250);
  }


  for(i=0;i<10;i++){ val[i]=0; }
  EEPROM_sequentialRead(0,10,val,0);
  val[10]='\0';


  for(i=0;i<10;i++){
   sprintf(str, "%3d at %2d", val[i], i);
   LCDWriteStringXY(0,1,str);
   _delay_ms(750);
  }
# 165 ".././CLICO.c"
  switch(bState){


   case 0:
    switch(bBtn){
     case 0:
      if(bTimeColonToToggle){ toggleTimeColon(); bTimeColonToToggle=0; }
      refreshQuote();
      bFirst=1;

      break;
     case 2:
     case 4:
     case 6:
     case 3:
     case 5:
      (*(volatile uint8_t *)((0x18) + 0x20)) |= 0x1; (*(volatile uint8_t *)((0x25) + 0x20)) |= (1<<2)|(0<<1)|(1<<0);;
      bBtn=0;
      break;
     case 7:
      bState = 1;
      (*(volatile uint8_t *)((0x18) + 0x20)) |= 0x1;;
      bBtn=0;
      break;
     default:
      break;
    }
    break;


   case 1:
    switch(bBtn){
     case 0:
      if(bSelectionMenuChanged || bFirst){
       bFirst=0;
       bSelectionMenuChanged=0;
       LCDWriteStringXY(0,0,"-");
       LCDWriteStringXY(1,0, options[bSelectionMenu]);
       LCDWriteStringXY(0,1," ");
       LCDWriteStringXY(1,1, options[bSelectionMenu+1]);
      }
      break;

     case 2:
      bSelectionMenu++;
      bSelectionMenu %= 7;
      bSelectionMenuChanged=1;
      bBtn=0;
      break;

     case 4:
      if(bSelectionMenu>0) bSelectionMenu--;
      else bSelectionMenu=(7 -1);
      bSelectionMenu %= 7;
      bSelectionMenuChanged=1;
      bBtn=0;
      break;

     case 6:
      switch(bSelectionMenu){
       case 1:
        bState = 2;
        bBtn = 0;
        break;
       case 2:
        bState = 4;
        bBtn = 0;
        break;
       case 0:
        bState = 6;
        bBtn = 0;
        break;
       default:
        break;
      }
      bFirst=1;
      break;

     case 7:
      bState = 0;
      bBtn=0;
      (*(volatile uint8_t *)((0x18) + 0x20)) &= 0xfe;;
      (*(volatile uint8_t *)((0x18) + 0x20)) |= 0x1; (*(volatile uint8_t *)((0x25) + 0x20)) |= (1<<2)|(0<<1)|(1<<0);;

      (LCDByte(0b00000001,0));; (LCDByte(0x02,0)); (LCDByte(0x0C,0));;

      bSelectionMenu=0;
      bDateChanged=1;
      bTimeChanged=1;
      bTempChanged=1;
      break;

     default:
      break;
    }
    break;


   case 2:
    switch(bBtn){
     case 0:
      if(bFirst){
       bFirst=0;
       (LCDByte(0b00000001,0));;
       tTimeEditing = tTime;
       sprintf(str, "%02d/%02d/%02d", tTimeEditing.bDay, tTimeEditing.bMonth, tTimeEditing.bYear);
       LCDWriteStringXY(0,0, "Editing date:");
       LCDWriteStringXY(3,1, str);
       (LCDByte(0x0f,0));
       for(i=0; i<8; i++) (LCDByte(0x10,0));;
      }
      break;
     case 2:
      bBtn = 0;
      changeEditDate(bSelectionDate, 2);
      sprintf(str, "%02d/%02d/%02d", tTimeEditing.bDay, tTimeEditing.bMonth, tTimeEditing.bYear);
      LCDWriteStringXY(3,1,str);
      for(i=0; i<8-bSelectionDate; i++) (LCDByte(0x10,0));;
      break;
     case 4:
      bBtn = 0;
      changeEditDate(bSelectionDate, 4);
      sprintf(str, "%02d/%02d/%02d", tTimeEditing.bDay, tTimeEditing.bMonth, tTimeEditing.bYear);
      LCDWriteStringXY(3,1,str);
      for(i=0; i<8-bSelectionDate; i++) (LCDByte(0x10,0));;
      break;
     case 6:
      if(bSelectionDate<7){ for(i=0; i<1; i++) (LCDByte(0x14,0));; bSelectionDate++; }
      else{ bSelectionDate=0; for(i=0; i<7; i++) (LCDByte(0x10,0));; }

      if(bSelectionDate==2 || bSelectionDate==5){
       for(i=0; i<1; i++) (LCDByte(0x14,0));;
       bSelectionDate++;
       if(checkDate(&tTimeEditing, aDays)){
        sprintf(str, "%02d/%02d/%02d", tTimeEditing.bDay, tTimeEditing.bMonth, tTimeEditing.bYear);
        LCDWriteStringXY(3,1,str);
        for(i=0; i<8-bSelectionDate; i++) (LCDByte(0x10,0));;
       }
      }
      bBtn = 0;
      break;
     case 7:
      bState=3;
      bBtn=0;
      bFirst=1;
      break;
     default:
      break;
    }
    break;


    case 3:
     switch(bBtn){
      case 0:
       if(bFirst){
        LCDWriteStringXY(0,0, "Confermi? Si/No");
        for(i=0; i<5; i++) (LCDByte(0x10,0));;
        bFirst=0;
        bSelectionDate=0;
       }
       if(bSelectionDateChanged){
        if(bSelectionDate==0){ (LCDByte(0b00000010,0));; for(i=0; i<10; i++) (LCDByte(0x14,0));; }
        else{ (LCDByte(0b00000010,0));; for(i=0; i<13; i++) (LCDByte(0x14,0));; }
        bSelectionDateChanged=0;
       }
       break;

      case 6:
       bSelectionDate = (bSelectionDate == 0)?1:0;
       bSelectionDateChanged=1;
       bBtn=0;
       break;

      case 7:
       if(bSelectionDate){
        bState = 1;
        bSelectionDate=0;
       }else{
        tTime.bDay = tTimeEditing.bDay;
        tTime.bMonth = tTimeEditing.bMonth;
        tTime.bYear = tTimeEditing.bYear;
        bState = 1;
        (LCDByte(0b00000001,0));; (LCDByte(0x02,0)); (LCDByte(0x0C,0));;
       }
       bBtn = 0;
       bFirst=1;
       break;
      default: break;
     }
    break;


   case 4:
     switch(bBtn){
      case 0:
       if(bFirst){
        bFirst=0;
        (LCDByte(0b00000001,0));;
        tTimeEditing = tTime;
        sprintf(str, "%02d:%02d:%02d", tTimeEditing.bHour, tTimeEditing.bMin, tTimeEditing.bSec);
        LCDWriteStringXY(0,0, "Editing time:");
        LCDWriteStringXY(3,1, str);
        (LCDByte(0x0f,0));
        for(i=0; i<8; i++) (LCDByte(0x10,0));;
       }
       break;
      case 2:
       bBtn = 0;
       changeEditTime(bSelectionTime, 2);
       sprintf(str, "%02d:%02d:%02d", tTimeEditing.bHour, tTimeEditing.bMin, tTimeEditing.bSec);
       LCDWriteStringXY(3,1,str);
       for(i=0; i<8-bSelectionTime; i++) (LCDByte(0x10,0));;
       break;
      case 4:
       bBtn = 0;
       changeEditTime(bSelectionTime, 4);
       sprintf(str, "%02d:%02d:%02d", tTimeEditing.bHour, tTimeEditing.bMin, tTimeEditing.bSec);
       LCDWriteStringXY(3,1,str);
       for(i=0; i<8-bSelectionTime; i++) (LCDByte(0x10,0));;
       break;
      case 6:
       if(bSelectionTime<7){ (LCDByte(0x14,0)); bSelectionTime++; }
       else{ bSelectionTime=0; for(i=0; i<7; i++) (LCDByte(0x10,0));; }
       if(bSelectionTime==2 || bSelectionTime==5){ (LCDByte(0x14,0)); bSelectionTime++; }
       bBtn = 0;
       break;
      case 7:
       bState=5;
       bBtn=0;
       bFirst=1;
       break;
      default:
       break;
     }
    break;


   case 5:
     switch(bBtn){
      case 0:
       if(bFirst){
        LCDWriteStringXY(0,0, "Confermi? Si/No");
        for(i=0; i<5; i++) (LCDByte(0x10,0));;
        bFirst=0;
        bSelectionTime=0;
       }
       if(bSelectionTimeChanged){
        if(bSelectionTime==0){ (LCDByte(0b00000010,0));; for(i=0; i<10; i++) (LCDByte(0x14,0));; }
        else{ (LCDByte(0b00000010,0));; for(i=0; i<13; i++) (LCDByte(0x14,0));; }
        bSelectionTimeChanged=0;
       }
       break;

      case 6:
       bSelectionTime = (bSelectionTime == 0)?1:0;
       bSelectionTimeChanged=1;
       bBtn=0;
       break;

      case 7:
       if(bSelectionTime){
        bState = 1;
        bSelectionTime=0;
       }else{
        tTime.bSec = tTimeEditing.bSec;
        tTime.bMin = tTimeEditing.bMin;
        tTime.bHour = tTimeEditing.bHour;
        bState = 1;
        (LCDByte(0b00000001,0));; (LCDByte(0x02,0)); (LCDByte(0x0C,0));;
       }
       bBtn = 0;
       bFirst=1;
       break;
      default: break;
     }
    break;


   case 6:
    switch(bBtn){
     case 0:
      if(bFirst){
       bFirst=0;
       (LCDByte(0b00000001,0));;
       LCDWriteStringXY(0,0, "Edit timezone:");
       LCDWriteStringXY(0,1,"1=");

      }
      break;
     default:
      break;
    }
    break;
   default:
    break;
  }
 }
}
# 474 ".././CLICO.c"
void __vector_15 (void) __attribute__ ((signal,used, externally_visible)) ; void __vector_15 (void){
 if(bPriLev<1) return;
 byte bOldPriLev = bPriLev;
 bPriLev=1;


 bPort = (*(volatile uint8_t *)((0x01) + 0x20));
 bBtnAPressed = bPort & 32;
 bBtnBPressed = bPort & 128;
 bBtnCPressed = bPort & 64;


 if(!bBtnCPressed&&(!bInhibite)){
  cButtonIntegrator.wC++;
  if(cButtonIntegrator.wC>100){ bInhibite=1; }
 }
 else{
  if(bBtnCPressed!=0){ bInhibite=0; }
  if(cButtonIntegrator.wC<15){ cButtonIntegrator.wC=0; }
  else if((cButtonIntegrator.wC>15)&&(cButtonIntegrator.wC<100)){
   cButtonIntegrator.wC=0;
   bBtn = 6;
  }else if(cButtonIntegrator.wC>100){
   cButtonIntegrator.wC=0;
   bBtn = 7;
  }
 }
 if(!bBtnAPressed){ cButtonIntegrator.wA++; }
 else{
  if(cButtonIntegrator.wA<15){ cButtonIntegrator.wA=0; }
  else{
   bBtn = 2;
   cButtonIntegrator.wA=0;
  }
 }
 if(!bBtnBPressed){ cButtonIntegrator.wB++; }
 else{
  if(cButtonIntegrator.wB<15){ cButtonIntegrator.wB=0; }
  else{
   bBtn = 4;
   cButtonIntegrator.wB=0;
  }
 }
 if((!bBtnAPressed)&&(!bBtnBPressed)){ cButtonIntegrator.wAB++; }
 else{
  if(cButtonIntegrator.wAB<15){ cButtonIntegrator.wAB=0; }
  else{
   bBtn = 8;
   cButtonIntegrator.wAB=0;
  }
 }




 if(tTime.wMilli<99) tTime.wMilli++;
 else{
  tTime.wMilli=0;
  if(tTime.bSec<59){ tTime.bSec++; bTimeColonToToggle=1; }
  else{
   tTime.bSec=0;
   if(tTime.bMin<59) tTime.bMin++;
   else{
    tTime.bMin=0;
    if(tTime.bHour<23) tTime.bHour++;
    else {
     tTime.bHour=0;
     if(tTime.bDay<(aDays[tTime.bMonth-1])){
      tTime.bDay++;
      if(tTime.bDay==29 && tTime.bMonth==2 && (!isLeapYear(tTime.bYear))){
       tTime.bDay=1;
       tTime.bMonth=3;
      }
     }else{
      tTime.bDay=1;
      if(tTime.bMonth<12) tTime.bMonth++;
      else{
       tTime.bMonth=1;
       tTime.bYear++;
      }
     }
     bDateChanged=1;
    }
   }
   bTimeChanged=1;
  }

 }
 bPriLev = bOldPriLev;
}


void __vector_9 (void) __attribute__ ((signal,used, externally_visible)) ; void __vector_9 (void){
 if(bPriLev<3) return;
 byte bOldPriLev = bPriLev;

 if(wBacklightCounter<300){ wBacklightCounter++; return; }
 wBacklightCounter=0;
 (*(volatile uint8_t *)((0x18) + 0x20)) &= 0xfe; (*(volatile uint8_t *)((0x25) + 0x20)) &= (0<<2)|(0<<1)|(0<<0);;

 bPriLev = bOldPriLev;
}


void __vector_21 (void) __attribute__ ((signal,used, externally_visible)) ; void __vector_21 (void){
 if(bPriLev<2) return;
 byte bOldPriLev = bPriLev;

 sreg = (*(volatile uint8_t *)((0x34) + 0x20));
 __asm__ __volatile__ ("cli" ::: "memory");

 if(wADC_garbage < 20){
  wADC_garbage++;
 }else{
  wADC_garbage=0;
  if(wADC_counts<100){
   switch(bChannel){
    case 0:
     adTemperature[wADC_counts]=getTemperature();
     break;
    case 1:
     adHumidity[wADC_counts]=getHumidity();
     break;
    default: break;
   }
   wADC_counts++;
  }else{
   wADC_counts=0;
   switch(bChannel){
    case 0:
     dTemperature=ADC_average(adTemperature, ((void *)0));
     bTempChanged=1;
     break;
    case 1:
     bHumidity = _round(ADC_average(((void *)0), adHumidity));
     bHumChanged=1;
     break;
    default: break;
   }
   multiplexADChannel();
  }
 }

 __asm__ __volatile__ ("sei" ::: "memory");
 (*(volatile uint8_t *)((0x34) + 0x20))=sreg;

 bPriLev = bOldPriLev;
}





void _init(){

 (*(volatile uint8_t *)((0x1A) + 0x20)) = 0xf;
 (*(volatile uint8_t *)((0x17) + 0x20)) = 0x1;

 (*(volatile uint8_t *)((0x03) + 0x20)) = 32 +128 +64;



 (*(volatile uint8_t *)((0x06) + 0x20)) = (1<<2)|(1<<1)|(1<<0);
 (*(volatile uint8_t *)((0x06) + 0x20)) |= (1<<5)|(1<<7)|(1<<3);
 (*(volatile uint8_t *)((0x07) + 0x20))=0; (*(volatile uint8_t *)((0x07) + 0x20)) |= (1<<3)|(1<<1)|(1<<0);;
# 647 ".././CLICO.c"
 InitLCD(0);
 (LCDByte(0b00000001,0));;
 LCDWriteStringXY(11,0,"00:00");
 LCDWriteStringXY(2 -2,1,"T=00.0");
 LCDByte(0b11011111, 1);

 LCDWriteStringXY(11 -4, 1, "C_H=88%");
 LCDWriteStringXY(15 -1,1,"_1");



 (*(volatile uint8_t *)((0x33) + 0x20)) |= (1<<2)|(1<<1)|(1<<0);
 (*(volatile uint8_t *)((0x33) + 0x20)) |= (1<<3)|(0<<6);
 (*(volatile uint8_t *)((0x37) + 0x20)) |= (1<<1);
 (*(volatile uint8_t *)((0x31) + 0x20)) = 155;


 (*(volatile uint8_t *)((0x25) + 0x20)) |= (1<<3)|(0<<6);
 (*(volatile uint8_t *)((0x37) + 0x20)) |= (1<<7);
 (*(volatile uint8_t *)((0x23) + 0x20)) = 156;


 __asm__ __volatile__ ("sei" ::: "memory");
 (*(volatile uint8_t *)((0x06) + 0x20)) |= 1<<6;
}


double getTemperature(){
 double temp;
 dVp = 2.5 + (*(volatile uint16_t *)((0x04) + 0x20)) * 5.0/(1024*200.0);
 dRpt = (dVp*(1200.0 +1100.0) - 5.0*1100.0)/(5.0 - dVp);
 temp = (dRpt-100) / 0.3878461538;

 return temp;
}

byte getHumidity(void){
 AD = (*(volatile uint16_t *)((0x04) + 0x20));
 dVout = 5*(AD/1024);
 dRH = (dVout - 0.16*5.0)/(5.0*0.0062);
 dRH_comp = dRH/(1.0546-0.00216*(_round(dTemperature)));
 return _round(dRH_comp);
}

void multiplexADChannel(){
 switch(bChannel){
  case 0:
   (*(volatile uint8_t *)((0x07) + 0x20))=0; (*(volatile uint8_t *)((0x07) + 0x20)) |= (1<<1);;
   bChannel=1;
   break;
  case 1:
   (*(volatile uint8_t *)((0x07) + 0x20))=0; (*(volatile uint8_t *)((0x07) + 0x20)) |= (1<<3)|(1<<1)|(1<<0);;
   bChannel = 0;
   break;
  default: break;
 }
}

double ADC_average(double * valuesDOUBLE, byte * valuesBYTE){
 sreg = (*(volatile uint8_t *)((0x34) + 0x20));
 __asm__ __volatile__ ("cli" ::: "memory");

 double value;
 double sumA=0;
 word sumB=0;
 word i;
 if(valuesDOUBLE != ((void *)0)){
  for(i=0;i<100;i++){
   sumA+=valuesDOUBLE[i];
  }
  value=sumA/i;
 }else{
  for(i=0;i<100;i++){
   sumB+=valuesBYTE[i];
  }
  value=sumB/i;
 }


 __asm__ __volatile__ ("sei" ::: "memory");
 (*(volatile uint8_t *)((0x34) + 0x20)) = sreg;
 return value;
}


void refreshQuote(){
 if(bDateChanged){
  bDateChanged=0;
  sprintf(str, "%02d/%02d/%02d,", tTime.bDay, tTime.bMonth, tTime.bYear);
  LCDWriteStringXY(0,0,str);
 }
 if(bTimeChanged){
  bTimeChanged=0;
  sprintf(str, "%02d", tTime.bHour);
  LCDWriteStringXY(11, 0, str);
  sprintf(str, "%02d", tTime.bMin);
  LCDWriteStringXY(11 +3, 0, str);
 }
 if(bTempChanged){
  bTempChanged=0;
  sprintf(str, "%04.1f", dTemperature);
  LCDWriteStringXY(0,1, "T=");
  LCDWriteStringXY(2,1, str);
 }
 if(bHumChanged){
  bHumChanged=0;
  sprintf(str, "%2d", bHumidity);
  LCDWriteStringXY(11, 1, str);
  if(bHumidity>99){ bOvFlo=1; }
  if(bHumidity<100 && bOvFlo){
   bOvFlo=0;
   LCDWriteStringXY(11 +2,1,"%");
  }
 }
}

int isLeapYear(byte year){
 if((year%4)==0) return 1;
 return 0;
}

void changeEditTime(byte bPosition, byte bButton){

 int bHunita;
 int bHdecine;
 int bMunita;
 int bMdecine;
 int bSunita;
 int bSdecine;

 bHunita = tTimeEditing.bHour % 10;
 bHdecine = tTimeEditing.bHour / 10;
 bMunita = tTimeEditing.bMin % 10;
 bMdecine = tTimeEditing.bMin / 10;
 bSunita = tTimeEditing.bSec % 10;
 bSdecine = tTimeEditing.bSec / 10;

 switch(bPosition){
  case 0:
   ;if(0==0){ if(bButton==2 && tTimeEditing.bHour<((2 -1)*10+(3 +1))){ tTimeEditing.bHour += 10; } else if(bButton == 4 && tTimeEditing.bHour > 9){ tTimeEditing.bHour -= 10; } }else{ if(bButton==2 && (bHunita<(3))){ tTimeEditing.bHour = bHdecine*10 + (++bHunita); } else if(bButton==2 && (bHdecine<(2)) && (bHunita<9)){ tTimeEditing.bHour = bHdecine*10 + (++bHunita); } else if(bButton==4 && (bHunita>0)){ tTimeEditing.bHour = bHdecine*10 + (--bHunita); }else{ ((void *)0); } }
   break;
  case 1:
   ;if(1==0){ if(bButton==2 && tTimeEditing.bHour<((2 -1)*10+(3 +1))){ tTimeEditing.bHour += 10; } else if(bButton == 4 && tTimeEditing.bHour > 9){ tTimeEditing.bHour -= 10; } }else{ if(bButton==2 && (bHunita<(3))){ tTimeEditing.bHour = bHdecine*10 + (++bHunita); } else if(bButton==2 && (bHdecine<(2)) && (bHunita<9)){ tTimeEditing.bHour = bHdecine*10 + (++bHunita); } else if(bButton==4 && (bHunita>0)){ tTimeEditing.bHour = bHdecine*10 + (--bHunita); }else{ ((void *)0); } }
   break;
  case 3:
   ;if(0==0){ if(bButton==2 && tTimeEditing.bMin<((5 -1)*10+(9 +1))){ tTimeEditing.bMin += 10; } else if(bButton == 4 && tTimeEditing.bMin > 9){ tTimeEditing.bMin -= 10; } }else{ if(bButton==2 && (bMunita<(9))){ tTimeEditing.bMin = bMdecine*10 + (++bMunita); } else if(bButton==2 && (bMdecine<(5)) && (bMunita<9)){ tTimeEditing.bMin = bMdecine*10 + (++bMunita); } else if(bButton==4 && (bMunita>0)){ tTimeEditing.bMin = bMdecine*10 + (--bMunita); }else{ ((void *)0); } }
   break;
  case 4:
   ;if(1==0){ if(bButton==2 && tTimeEditing.bMin<((5 -1)*10+(9 +1))){ tTimeEditing.bMin += 10; } else if(bButton == 4 && tTimeEditing.bMin > 9){ tTimeEditing.bMin -= 10; } }else{ if(bButton==2 && (bMunita<(9))){ tTimeEditing.bMin = bMdecine*10 + (++bMunita); } else if(bButton==2 && (bMdecine<(5)) && (bMunita<9)){ tTimeEditing.bMin = bMdecine*10 + (++bMunita); } else if(bButton==4 && (bMunita>0)){ tTimeEditing.bMin = bMdecine*10 + (--bMunita); }else{ ((void *)0); } }
   break;
  case 6:
   ;if(0==0){ if(bButton==2 && tTimeEditing.bSec<((5 -1)*10+(9 +1))){ tTimeEditing.bSec += 10; } else if(bButton == 4 && tTimeEditing.bSec > 9){ tTimeEditing.bSec -= 10; } }else{ if(bButton==2 && (bSunita<(9))){ tTimeEditing.bSec = bSdecine*10 + (++bSunita); } else if(bButton==2 && (bSdecine<(5)) && (bSunita<9)){ tTimeEditing.bSec = bSdecine*10 + (++bSunita); } else if(bButton==4 && (bSunita>0)){ tTimeEditing.bSec = bSdecine*10 + (--bSunita); }else{ ((void *)0); } }
   break;
  case 7:
   ;if(1==0){ if(bButton==2 && tTimeEditing.bSec<((5 -1)*10+(9 +1))){ tTimeEditing.bSec += 10; } else if(bButton == 4 && tTimeEditing.bSec > 9){ tTimeEditing.bSec -= 10; } }else{ if(bButton==2 && (bSunita<(9))){ tTimeEditing.bSec = bSdecine*10 + (++bSunita); } else if(bButton==2 && (bSdecine<(5)) && (bSunita<9)){ tTimeEditing.bSec = bSdecine*10 + (++bSunita); } else if(bButton==4 && (bSunita>0)){ tTimeEditing.bSec = bSdecine*10 + (--bSunita); }else{ ((void *)0); } }
   break;
  default:
   break;
 }

}

void changeEditDate(byte bPosition, byte bButton){

 int bYunita;
 int bYdecine;
 int bMunita;
 int bMdecine;
 int bDunita;
 int bDdecine;

 bYunita = tTimeEditing.bYear % 10;
 bYdecine = tTimeEditing.bYear / 10;
 bMunita = tTimeEditing.bMonth % 10;
 bMdecine = tTimeEditing.bMonth / 10;
 bDunita = tTimeEditing.bDay % 10;
 bDdecine = tTimeEditing.bDay / 10;

 switch(bPosition){
  case 0:
   ;if(0==0){ if(bButton==2 && tTimeEditing.bDay<((3 -1)*10+(1 +1))){ tTimeEditing.bDay += 10; } else if(bButton == 4 && tTimeEditing.bDay > 9){ tTimeEditing.bDay -= 10; } }else{ if(bButton==2 && (bDunita<(1))){ tTimeEditing.bDay = bDdecine*10 + (++bDunita); } else if(bButton==2 && (bDdecine<(3)) && (bDunita<9)){ tTimeEditing.bDay = bDdecine*10 + (++bDunita); } else if(bButton==4 && (bDunita>0)){ tTimeEditing.bDay = bDdecine*10 + (--bDunita); }else{ ((void *)0); } }
   break;
  case 1:
   ;if(1==0){ if(bButton==2 && tTimeEditing.bDay<((3 -1)*10+(1 +1))){ tTimeEditing.bDay += 10; } else if(bButton == 4 && tTimeEditing.bDay > 9){ tTimeEditing.bDay -= 10; } }else{ if(bButton==2 && (bDunita<(1))){ tTimeEditing.bDay = bDdecine*10 + (++bDunita); } else if(bButton==2 && (bDdecine<(3)) && (bDunita<9)){ tTimeEditing.bDay = bDdecine*10 + (++bDunita); } else if(bButton==4 && (bDunita>0)){ tTimeEditing.bDay = bDdecine*10 + (--bDunita); }else{ ((void *)0); } }
   if(tTimeEditing.bDay==0) tTimeEditing.bDay=1;
   break;
  case 3:
   ;if(0==0){ if(bButton==2 && tTimeEditing.bMonth<((1 -1)*10+(2 +1))){ tTimeEditing.bMonth += 10; } else if(bButton == 4 && tTimeEditing.bMonth > 9){ tTimeEditing.bMonth -= 10; } }else{ if(bButton==2 && (bMunita<(2))){ tTimeEditing.bMonth = bMdecine*10 + (++bMunita); } else if(bButton==2 && (bMdecine<(1)) && (bMunita<9)){ tTimeEditing.bMonth = bMdecine*10 + (++bMunita); } else if(bButton==4 && (bMunita>0)){ tTimeEditing.bMonth = bMdecine*10 + (--bMunita); }else{ ((void *)0); } }
   break;
  case 4:
   ;if(1==0){ if(bButton==2 && tTimeEditing.bMonth<((1 -1)*10+(2 +1))){ tTimeEditing.bMonth += 10; } else if(bButton == 4 && tTimeEditing.bMonth > 9){ tTimeEditing.bMonth -= 10; } }else{ if(bButton==2 && (bMunita<(2))){ tTimeEditing.bMonth = bMdecine*10 + (++bMunita); } else if(bButton==2 && (bMdecine<(1)) && (bMunita<9)){ tTimeEditing.bMonth = bMdecine*10 + (++bMunita); } else if(bButton==4 && (bMunita>0)){ tTimeEditing.bMonth = bMdecine*10 + (--bMunita); }else{ ((void *)0); } }
   if(tTimeEditing.bMonth==0) tTimeEditing.bMonth=1;
   break;
  case 6:
   ;if(0==0){ if(bButton==2 && tTimeEditing.bYear<((9 -1)*10+(9 +1))){ tTimeEditing.bYear += 10; } else if(bButton == 4 && tTimeEditing.bYear > 9){ tTimeEditing.bYear -= 10; } }else{ if(bButton==2 && (bYunita<(9))){ tTimeEditing.bYear = bYdecine*10 + (++bYunita); } else if(bButton==2 && (bYdecine<(9)) && (bYunita<9)){ tTimeEditing.bYear = bYdecine*10 + (++bYunita); } else if(bButton==4 && (bYunita>0)){ tTimeEditing.bYear = bYdecine*10 + (--bYunita); }else{ ((void *)0); } }
   break;
  case 7:
   ;if(1==0){ if(bButton==2 && tTimeEditing.bYear<((9 -1)*10+(9 +1))){ tTimeEditing.bYear += 10; } else if(bButton == 4 && tTimeEditing.bYear > 9){ tTimeEditing.bYear -= 10; } }else{ if(bButton==2 && (bYunita<(9))){ tTimeEditing.bYear = bYdecine*10 + (++bYunita); } else if(bButton==2 && (bYdecine<(9)) && (bYunita<9)){ tTimeEditing.bYear = bYdecine*10 + (++bYunita); } else if(bButton==4 && (bYunita>0)){ tTimeEditing.bYear = bYdecine*10 + (--bYunita); }else{ ((void *)0); } }
   break;
  default:
   break;
 }
}

int checkDate(time_date *time, byte * days){



 if(time->bDay > days[time->bMonth-1]){
  time->bDay = days[time->bMonth-1];
  return 1;
 }
 return 0;
}

void toggleTimeColon(){
 if(bTimeCommaState){
  LCDWriteStringXY(11 +2, 0, ":");
  bTimeCommaState=0;
 }else{
  LCDWriteStringXY(11 +2, 0, " ");
  bTimeCommaState=1;
 }
}

int _round(double x){
 if((x-((int)x))>0.5) return ((int)x)+1;
 else return (int)x;
}
